using System.Data.Entity;
using System.Threading.Tasks;

namespace IR.Application.Interfaces
{
    public interface IDatabaseService
    {
        IDbSet<Domain.Entities.BAT> Bat { get; set; }
        IDbSet<Domain.Entities.CUST> Cust { get; set; }
        IDbSet<Domain.Entities.CUST_REF_TYPE> CustRefType { get; set; }
        IDbSet<Domain.Entities.IR_REF_TYPE> IrRefType { get; set; }
        IDbSet<Domain.Entities.INV_STS_HIST> InvStsHist { get; set; }
        IDbSet<Domain.Entities.INV> Inv { get; set; }
        IDbSet<Domain.Entities.IR_EVENT_LOG> IrEventLog { get; set; }
        IDbSet<Domain.Entities.LOCKBOX_CUST> LockboxCust { get; set; }
        IDbSet<Domain.Entities.REF_ITEM> RefItem { get; set; }
        IDbSet<Domain.Entities.TXN> Txn { get; set; }
        IDbSet<Domain.Entities.REM_WH_REF_ITEM> RemWhRefItem { get; set; }
        IDbSet<Domain.Entities.INV_IDEN_EXTRACT> InvIdenExtract { get; set; }
        IDbSet<Domain.Entities.PYMT> Pymt { get; set; }
        IDbSet<Domain.Entities.REM_WH_TXN_HST> RemWhTxnHst { get; set; }

        void Save();
        int SaveChanges();
        Task<int> SaveAsync();
    }
}

using System.Linq;
using System.Threading.Tasks;

namespace IR.Application.Interfaces
{
    public interface IDataRepository<T> where T : class
    {
        IQueryable<T> GetAll();
        T GetById(long id);
        Task<T> GetByIdAsync(long id);
        void Add(T entity);
        void Update(T entity);
        void Delete(T entity);
        void Delete(int id);
        void Detach(T entity);
    }
}

using System;
using System.Threading.Tasks;

namespace IR.Application.Interfaces
{
    public interface IDataUnitOfWork : IDisposable
    {
        IDataRepository<Domain.Entities.BAT> BatRepository { get; }
        IDataRepository<Domain.Entities.CUST> CustRepository { get; }
        IDataRepository<Domain.Entities.CUST_REF_TYPE> CustRefTypeRepository { get; }
        IDataRepository<Domain.Entities.IR_REF_TYPE> IrRefTypeRepository { get; }
        IDataRepository<Domain.Entities.INV_STS_HIST> InvStsHistRepository { get; }
        IDataRepository<Domain.Entities.INV> InvRepository { get; }
        IDataRepository<Domain.Entities.IR_EVENT_LOG> IrEventLogRepository { get; }
        IDataRepository<Domain.Entities.LOCKBOX_CUST> LockboxCustRepository { get; }
        IDataRepository<Domain.Entities.REF_ITEM> RefItemRepository { get; }
        IDataRepository<Domain.Entities.TXN> TxnRepository { get; }
        IDataRepository<Domain.Entities.REM_WH_REF_ITEM> RemWhRefItemRepository { get; }
        IDataRepository<Domain.Entities.INV_IDEN_EXTRACT> InvIdenExtractRepository { get; }
        IDataRepository<Domain.Entities.PYMT> PymtRepository { get; }
        IDataRepository<Domain.Entities.REM_WH_TXN_HST> RemWhTxnHstRepository { get; }

        long InvStsHistSeqNextval { get; }
        long RefItemSeqNextval { get; }

        void SaveChanges();
        Task<bool> SaveChangesAsync();
    }
}

using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using IR.Common.Util;
using IR.Application.Interfaces;
using IR.Domain.Entities;
using System;

namespace IR.Persistence
{
    public class DatabaseService : DbContext, IDatabaseService
    {
        public IDbSet<BAT> Bat { get; set; }
        public IDbSet<CUST> Cust { get; set; }
        public IDbSet<CUST_REF_TYPE> CustRefType { get; set; }
        public IDbSet<IR_REF_TYPE> IrRefType { get; set; }
        public IDbSet<IR_EVENT_LOG> IrEventLog { get; set; }
        public IDbSet<INV_STS_HIST> InvStsHist { get; set; }
        public IDbSet<INV> Inv { get; set; }
        public IDbSet<LOCKBOX_CUST> LockboxCust { get; set; }
        public IDbSet<REF_ITEM> RefItem { get; set; }
        public IDbSet<TXN> Txn { get; set; }
        public IDbSet<REM_WH_REF_ITEM> RemWhRefItem { get; set; }
        public IDbSet<INV_IDEN_EXTRACT> InvIdenExtract { get; set; }
        public IDbSet<PYMT> Pymt { get; set; }
        public IDbSet<REM_WH_TXN_HST> RemWhTxnHst { get; set; }

        public DatabaseService() : base(ConnectionStringName)
        {

            if (PasswordEncrypted)
                Database.Connection.ConnectionString = GetDecryptedConnectionstring;

            Database.SetInitializer<DatabaseService>(null);
            Configuration.AutoDetectChangesEnabled = false;
            Configuration.LazyLoadingEnabled = false;
            Configuration.ProxyCreationEnabled = false;
        }

        private static bool PasswordEncrypted => bool.Parse(ConfigurationManager.AppSettings["encrypted"]);

        private static string DbSchemaName => ConfigurationManager.AppSettings["DatabaseSchemaName"];

        private string GetDecryptedConnectionstring =>
            $"{Database.Connection.ConnectionString};PASSWORD={EncryptionHelper.Decrypt(ConfigurationManager.AppSettings["OracleConnectionStringPassword"])}";

        private static string ConnectionStringName =>
            ConfigurationManager.AppSettings["ConnectionStringName"] != null
                ? ConfigurationManager.AppSettings["ConnectionStringName"]
                : ConfigurationManager.ConnectionStrings["DefaultConnection"].ConnectionString;


        public void Save()
        {
            SaveChanges();
        }

        public override int SaveChanges()
        {
            try
            {
                return base.SaveChanges();
            }
            catch (DbEntityValidationException ex)
            {
                // Retrieve the error messages as a list of strings.
                var errorMessages = ex.EntityValidationErrors
                    .SelectMany(x => x.ValidationErrors)
                    .Select(x => x.ErrorMessage);

                // Join the list to a single string.
                var fullErrorMessage = string.Join("; ", errorMessages);

                // Combine the original exception message with the new one.
                var exceptionMessage = string.Concat(ex.Message, " The validation errors are: ", fullErrorMessage);

                // Throw a new DbEntityValidationException with the improved exception message.
                throw new DbEntityValidationException(exceptionMessage, ex.EntityValidationErrors);
            }
        }

        public async Task<int> SaveAsync()
        {
            return await SaveChangesAsync();
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            modelBuilder.HasDefaultSchema(DbSchemaName);

            modelBuilder.Properties<string>().Configure(c => c.IsUnicode(false));
        }
    }
}

using IR.Application.Interfaces;
using System;
using System.Threading.Tasks;
using IR.Domain.Entities;
using System.Linq;

namespace IR.Persistence
{
    public class DataUnitOfWork : IDataUnitOfWork
    {
        private bool _disposed;
        private DatabaseService _dbContext = new DatabaseService();

        private IDataRepository<BAT> _bat;
        private IDataRepository<CUST> _cust;
        private IDataRepository<CUST_REF_TYPE> _custRefType;
        private IDataRepository<IR_REF_TYPE> _irRefType;
        private IDataRepository<INV_STS_HIST> _invStsHist;
        private IDataRepository<INV> _inv;
        private IDataRepository<IR_EVENT_LOG> _irEventLog;
        private IDataRepository<LOCKBOX_CUST> _lockboxCust;
        private IDataRepository<REF_ITEM> _refItem;
        private IDataRepository<TXN> _txn;
        private IDataRepository<REM_WH_REF_ITEM> _remWhRefItem;
        private IDataRepository<INV_IDEN_EXTRACT> _invIdenExtract;
        private IDataRepository<PYMT> _pymt;
        private IDataRepository<REM_WH_TXN_HST> _remWhTxnHst;

        public IDataRepository<BAT> BatRepository => _bat ?? (_bat = new GenericRepository<BAT>(_dbContext));
        public IDataRepository<CUST> CustRepository => _cust ?? (_cust = new GenericRepository<CUST>(_dbContext));
        public IDataRepository<CUST_REF_TYPE> CustRefTypeRepository => _custRefType ?? (_custRefType = new GenericRepository<CUST_REF_TYPE>(_dbContext));
        public IDataRepository<IR_REF_TYPE> IrRefTypeRepository => _irRefType ?? (_irRefType = new GenericRepository<IR_REF_TYPE>(_dbContext));
        public IDataRepository<INV_STS_HIST> InvStsHistRepository => _invStsHist ?? (_invStsHist = new GenericRepository<INV_STS_HIST>(_dbContext));
        public IDataRepository<INV> InvRepository => _inv ?? (_inv = new GenericRepository<INV>(_dbContext));
        public IDataRepository<IR_EVENT_LOG> IrEventLogRepository => _irEventLog ?? (_irEventLog = new GenericRepository<IR_EVENT_LOG>(_dbContext));
        public IDataRepository<LOCKBOX_CUST> LockboxCustRepository => _lockboxCust ?? (_lockboxCust = new GenericRepository<LOCKBOX_CUST>(_dbContext));
        public IDataRepository<REF_ITEM> RefItemRepository => _refItem ?? (_refItem = new GenericRepository<REF_ITEM>(_dbContext));
        public IDataRepository<TXN> TxnRepository => _txn ?? (_txn = new GenericRepository<TXN>(_dbContext));
        public IDataRepository<REM_WH_REF_ITEM> RemWhRefItemRepository => _remWhRefItem ?? (_remWhRefItem = new GenericRepository<REM_WH_REF_ITEM>(_dbContext));
        public IDataRepository<INV_IDEN_EXTRACT> InvIdenExtractRepository => _invIdenExtract ?? (_invIdenExtract = new GenericRepository<INV_IDEN_EXTRACT>(_dbContext));
        public IDataRepository<PYMT> PymtRepository => _pymt ?? (_pymt = new GenericRepository<PYMT>(_dbContext));
        public IDataRepository<REM_WH_TXN_HST> RemWhTxnHstRepository => _remWhTxnHst ?? (_remWhTxnHst = new GenericRepository<REM_WH_TXN_HST>(_dbContext));

        public long InvStsHistSeqNextval => _dbContext.Database.SqlQuery<long>("SELECT INV_STS_HIST_SEQ.NEXTVAL FROM DUAL").FirstOrDefault();
        public long RefItemSeqNextval => _dbContext.Database.SqlQuery<long>("SELECT REF_ITEM_SEQ.NEXTVAL FROM DUAL").FirstOrDefault();

        public void SaveChanges()
        {
            if (_disposed)
                throw new ObjectDisposedException(GetType().Name);

            _dbContext.Save();
        }

        public async Task<bool> SaveChangesAsync()
        {
            var result = await _dbContext.SaveAsync();
            return result > 0;
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (_disposed)
                return;

            if (!disposing) return;
            if (_dbContext != null)
            {
                _dbContext.Dispose();
                _dbContext = null;
            }
            _disposed = true;
        }
    }
}

using System;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using IR.Application.Interfaces;
using System.Threading.Tasks;

namespace IR.Persistence
{
    public class GenericRepository<T> : IDataRepository<T> where T : class
    {
        protected DbSet<T> DBSet { get; set; }

        protected DbContext Context { get; set; }

        public GenericRepository(DbContext context)
        {
            if (context == null)
            {
                throw new ArgumentNullException("An instance of DbContext is " + "required to use this repository.", "context");
            }
            this.Context = context;
            this.DBSet = this.Context.Set<T>();
        }

        public virtual IQueryable<T> GetAll()
        {
            return this.DBSet;
        }

        public virtual T GetById(long id)
        {
            return this.DBSet.Find(id);
        }

        public virtual async Task<T> GetByIdAsync(long id)
        {
            return await this.DBSet.FindAsync(id);
        }

        public virtual void Add(T entity)
        {
            DbEntityEntry entry = this.Context.Entry(entity);
            if (entry.State != EntityState.Detached)
            {
                entry.State = EntityState.Added;
            }
            else
            {
                this.DBSet.Add(entity);
            }

        }

        public virtual void Update(T entity)
        {
            DbEntityEntry entry = this.Context.Entry(entity);
            if (entry.State == EntityState.Detached)
            {
                this.DBSet.Attach(entity);
            }

            entry.State = EntityState.Modified;
        }

        public virtual void Delete(T entity)
        {
            DbEntityEntry entry = this.Context.Entry(entity);
            if (entry.State != EntityState.Deleted)
            {
                entry.State = EntityState.Deleted;
            }
            else
            {
                this.DBSet.Attach(entity);
                this.DBSet.Remove(entity);
            }
        }

        public virtual void Delete(int id)
        {
            var entity = this.GetById(id);
            if (entity != null)
            {
                this.Delete(entity);
            }
        }

        public virtual void Detach(T entity)
        {
            DbEntityEntry entry = this.Context.Entry(entity);
            entry.State = EntityState.Detached;
        }
    }
}

using IR.Application.Interfaces;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace IR.Application.REM_WH_REF_ITEM.Queries
{
    public class RemWhRefItemQuery : IRemWhRefItemQuery
    {
        private readonly IDataUnitOfWork _database;

        public RemWhRefItemQuery(IDataUnitOfWork database)
        {
            _database = database;
        }
        public async Task<IEnumerable<RemWhRefItemModel>> GetUnmatchedInvoices(long txnId)
        {
            var query = from pymt in _database.PymtRepository.GetAll()
                        join hst in _database.RemWhTxnHstRepository.GetAll() on pymt.PYMT_ID equals hst.PYMT_ID
                        join rem in _database.RemWhRefItemRepository.GetAll() on hst.REM_WH_TXN_ID equals rem.REM_WH_TXN_ID
                        join refitem in _database.RefItemRepository.GetAll()
                             on new { invId = rem.INV_ID, refId = rem.REF_TYPE_ID, procDate = procDt }
                             equals new { invId = refitem.INV_ID, refId = refitem.REF_TYPE_ID, procDate = refitem.PROC_DT }
                             into gj
                        from refItemMatch in gj.DefaultIfEmpty()
                        where pymt.TXN_ID == txnId &&
                        rem.INV_ID != null &&
                        refItemMatch == null
                        select new RemWhRefItemModel()
                        {
                            TxnId = pymt.TXN_ID.Value,
                            PymtId = hst.PYMT_ID,
                            InvId = rem.INV_ID.Value,
                            RefTypeId = rem.REF_TYPE_ID ?? 0,
                            AlumValue = rem.ALNUM_VAL_TX,
                            NumValue = rem.NUM_VAL_AM,
                            RefItemDate = rem.REF_ITEM_DT,
                            RowSeqNb = rem.REF_ITEM_ROW_SEQ_NB
                        };

            var result = await (query).ToListAsync();

            return result;
        }
    }
}

using IR.Application.INV.Commands;
using IR.Application.Interfaces;
using System;
using System.Threading.Tasks;
using IR.Application.CUST.Queries;
using IR.Application.INV_STS_HIST.Commands;
using IR.Application.INV_IDEN_EXTRACT.Queries;
using IR.Application.CUST_REF_TYPE.Queries;
using IR.Application.REF_ITEM.Queries;
using IR.Application.REF_ITEM.Commands;
using System.Collections.Generic;
using IR.Application.REM_WH_REF_ITEM.Queries;
using System.Linq;

namespace IR.Application.Rules
{
    public class KeepRule : IRule
    {
        private readonly IDataUnitOfWork _database;
        private readonly IInvIdenExtractQuery _invIdenExtractQuery;
        private readonly IRemWhRefItemQuery _remWhRefItemQuery;
        private readonly IGetCustRefTypeQuery _getCustRefTypeQuery;
        private readonly IGetRefItemQuery _getRefItemQuery;
        private readonly IAddRefItemCommand _addRefItemCommand;
        private readonly IInvCommand _invCommand;
        private readonly IInvStsHistCommand _invStsHistCommand;

        public KeepRule(IDataUnitOfWork database, IInvIdenExtractQuery invIdenExtractQuery, IRemWhRefItemQuery remWhRefItemQuery, IGetCustRefTypeQuery getCustRefTypeQuery, IGetRefItemQuery getRefItemQuery, IAddRefItemCommand addRefItemCommand, IInvCommand invCommand, IInvStsHistCommand invStsHistCommand)
        {
            _database = database;
            _invIdenExtractQuery = invIdenExtractQuery;
            _remWhRefItemQuery = remWhRefItemQuery;
            _getCustRefTypeQuery = getCustRefTypeQuery;
            _getRefItemQuery = getRefItemQuery;
            _addRefItemCommand = addRefItemCommand;
            _invCommand = invCommand;
            _invStsHistCommand = invStsHistCommand;
        }

        public async Task ExecuteAsync(CustModel customer)
        {
            await ProcessUnmatchedInvoices(customer, await _invIdenExtractQuery.GetUnmatchedInvoices(customer.TxnId, customer.ProcDt));
            await ProcessUnmatchedInvoices(customer, await _remWhRefItemQuery.GetUnmatchedInvoices(customer.TxnId));
        }

        private async Task ProcessUnmatchedInvoices(CustModel customer, IEnumerable<InvIdenExtractModel> unmatchedInvoices)
        {
            foreach (var invoice in unmatchedInvoices)
            {
                var custRefType = await _getCustRefTypeQuery.ExecuteAsync(customer.CustId, invoice.RefId);
                var refItem = CreateRefItem(invoice.InvId, customer, custRefType);

                refItem.REF_ITEM_ROW_SEQ_NB = await _getRefItemQuery.ExecuteNewRowSeqAsync(customer);

                _addRefItemCommand.ExecuteAsync(RefItemValueHelper.Transform(refItem, custRefType.DataType, invoice.ExtractValue));

                await _invCommand.UpdateInvoiceStatusAsync(invoice.InvId, InvStatusCode.RepairRequired);
                await _invStsHistCommand.InsertInvStsHistRecord(customer, invoice.InvId, InvStatusCode.RepairRequired);

                await _database.SaveChangesAsync();
            }
        }

        private async Task ProcessUnmatchedInvoices(CustModel customer, IEnumerable<RemWhRefItemModel> unmatchedInvoices)
        {
            foreach (var rowSeqGroup in unmatchedInvoices.OrderBy(u => u.RowSeqNb).GroupBy(x => x.RowSeqNb))
            {
                var rowSeqNb = await _getRefItemQuery.ExecuteNewRowSeqAsync(customer);
                foreach (var remWhRefItem in rowSeqGroup)
                {
                    var custRefType = await _getCustRefTypeQuery.ExecuteAsync(customer.CustId, remWhRefItem.RefTypeId);
                    var refItem = CreateRefItem(remWhRefItem.InvId, customer, custRefType);

                    refItem.REF_ITEM_ROW_SEQ_NB = rowSeqNb;
                    refItem.ALNUM_VAL_TX = remWhRefItem.AlumValue;
                    refItem.NUM_VAL_AM = remWhRefItem.NumValue;
                    refItem.REF_ITEM_DT = remWhRefItem.RefItemDate;

                    _addRefItemCommand.ExecuteAsync(refItem);
                    await _database.SaveChangesAsync();
                }

                foreach (var invId in rowSeqGroup.Where(x => x.InvId != null).Select(x => x.InvId).Distinct())
                {
                    await _invCommand.UpdateInvoiceStatusAsync(invId.Value, InvStatusCode.RepairRequired);
                    await _invStsHistCommand.InsertInvStsHistRecord(customer, invId.Value, InvStatusCode.RepairRequired);
                    await _database.SaveChangesAsync();
                }
            }
        }

        private Domain.Entities.REF_ITEM CreateRefItem(long? invoiceId, CustModel customer, CustRefTypeModel custRefType)
        {
            var colSeqNb = custRefType?.SeqId ?? 1;

            return new Domain.Entities.REF_ITEM()
            {
                REF_ITEM_ID = _database.RefItemSeqNextval,
                INV_ID = invoiceId,
                REF_TYPE_ID = custRefType.RefTypeId,
                REF_ITEM_COL_SEQ_NB = colSeqNb,
                LAST_UPDT_TS = DateTime.Now,
                LAST_UPDT_USR_ID = 2,
                CRE_BY_CD = "0",
                TXN_ID = customer.TxnId,
                PROC_DT = customer.ProcDt
            };
        }

    }
}

